{"title":"Nginx前端手册","content":"# Nginx简介\nNginx是一个高性能、轻量级的Web和反向代理服务器, 其特点是占有内存及资源少、抗并发能力强。\nNginx安装简单、配置简洁、启动快速便捷、支持热部署、支持 SSL、拥有高度模块化的设计。  \nNginx的主要功能有:  \n\n+ Web服务器  \n+ 反向代理  \n+ 负载均衡  \n# 运行和控制Nginx\n备注: 以下命令中的 /usr/local/nginx 是nginx二进制文件的绝对路径，需根据自己实际的安装路径而定。\n\n+ 启动\n/usr/local/nginx/sbin/nginx\n+ 重新打开日志文件\n/usr/local/nginx/sbin/nginx -s reopen\n+ 重新载入配置文件\n/usr/local/nginx/sbin/nginx -s reload\n+ 停止\n/usr/local/nginx/sbin/nginx -s stop\n+ 从容停止 \n  + 查看进程号\nps -ef|grep nginx\n  + 杀死进程\nkill -QUIT <进程号> 或 kill -TERM <进程号>\n+ 强制停止\npkill -9 nginx\n# Nginx作为Web服务器\nNginx作为Web服务器, 需要定义server虚拟主机，让这些虚拟主机去处理对于特定域名或IP地址的请求。  \n每个server虚拟主机都定义了 location 指令，location 定义了对于指定的一组 URI 是如何匹配和进行处理的。  \n\n## Web服务器基本实例\n```\nserver {\n  listen 80;\n  server_name www.example.com;\n  location / {\n  root /usr/local/www;\n    index index.html;\n  }    \n}\n参数说明:  \nserver 代表1个虚拟主机，可以有多个  \nserver_name 匹配请求的指定域名或IP地址  \nlocation 配置请求的路由，匹配对应的URI  \nroot 查找资源的路径(文件夹目录)  \nindex 默认查找    \n```\n## Location匹配规则（请求过滤）  \n+ 语法\n```\nserver {\n   location 表达式 {\n   }\n}\n```\n+ Location表达式的类型  \n@ 它定义一个命名的 location，使用在内部定向时，例如 error_page, try_files\n/ 通用匹配，任何请求都会匹配到  \n= 开头, 表示精确匹配, 只有请求的url路径与=后面的字符串完全相等才会匹配到（优先级最高）  \n^~ 表示普通字符匹配。使用前缀匹配。如果匹配成功，则不再匹配其他location  \n~ 开头表示区分大小写的正则匹配  \n~* 开头表示不区分大小写的正则匹配  \n+ Location表达式的优先级  \n= 的优先级最高。一旦匹配成功，则不再查找其他匹配项。  \n^~ 类型表达式。一旦匹配成功，则不再查找其他匹配项。  \n~ 和 ~* 的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。  \n常规字符串匹配类型。按前缀匹配。  \n## URL重写  \nURL重写是指: 当请求的URL满足事先定义好的规则时, 将跳转/定向到某个规则，比如常见的伪静态、301重定向、浏览器定向等。  \n+ 语法  \n```\nserver {\n   rewrite 规则 定向路径 重写类型;\n}\n```\nrewrite参数说明:  \n规则：字符串或者正则来表示想匹配的目标url  \n定向路径：匹配到规则后要定向的路径，如果规则里有正则，则可以使用$index来表示正则里的捕获分组  \n重写类型：  \nlast ：表示完成rewrite，浏览器地址栏URL地址不变  \nbreak；本条规则匹配完成后，终止匹配，不再匹配后面的规则，浏览器地址栏URL地址不变  \nredirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址  \npermanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址  \n+ 示例   \n域名跳转: 访问 http://www.aaa.com 跳转到 http://www.bbb.com\n```\nserver {\n  listen 80;\n  server_name  www.aaa.com;\n  location / {\n   rewrite ^/$ www.bbb.com permanent ;\n  }\n}\n```\n## Try_files  \ntry_files是指: 按顺序检查文件是否存在，返回第一个找到的文件。如果所有的文件都找不到，会进行一个内部重定向到最后一个参数.    \n+ 语法\ntry_files file1 files2 ... uri  \n参数说明:    \n最后一个参数是回退URI, 且必须存在，否则将会出现内部500错误。  \n只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向。  \n最后一个参数也可以是一个命名的location。  \n最后一个参数如果不是命名的location那么$args不会自动保留，如果你想保留$args， 必须在最后一个参数里明确声明。示例为:  \ntry_files $uri $uri/ /index.php?q=$uri&$args;  \n+ 示例  \n跳转到文件  \n当访问:http://www.example.com/test 时会依次查找，若 1.html，2.html 都不存在，最终返回 3.html  \n```\nserver {\n  listen 80;\n  server_name www.example.com;\n  root html;\n  index index.html;\n  location /test {\n        try_files /1.html /2.html /3.html;\n    }\n}\n```\n+ 跳转到变量  \n当访问:http://www.example.com/test 时会依次查找，若 1.html，2.html 都不存在，则跳转到命名为abc的location\n```\nserver {\n  listen 80;\n  server_name www.example.com;\n  root html;\n  index index.html;             \n  location /test {\n    try_files /1.html /2.html @abc;\n  }\n  location @abc{\n    rewrite ^/(.*)$  http://www.example2.com;\n  }\n}\n```\nvue-router设置HTML5 History 模式时, nginx的配置如下:\n```\nlocation / {\n    # URL 匹配不到任何静态资源，返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。\n    try_files $uri $uri/ /index.html;\n}\n```\n## Gzip配置\n```\nserver {\n  # 开启gzip 压缩\n  gzip on;\n  # 设置gzip所需的http协议最低版本 （HTTP/1.1, HTTP/1.0）\n  gzip_http_version 1.1;\n  # 设置压缩级别（1-9）, 值越大压缩率越高，同时消耗cpu资源也越多，建议设置在4左右\n  gzip_comp_level 4;\n  # 设置压缩的最小字节数， 页面Content-Length获取\n  gzip_min_length 1000;\n  # 设置压缩文件的类型  （text/html), 不建议压缩图片(如jpg、png本身已压缩)\n  gzip_types text/plain application/javascript text/css;\n #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）\n gzip_disable \"MSIE [1-6]\\.\";\n}\n```\n## Https配置\n```\nhttp {\n  # 配置共享会话缓存大小，视站点访问情况设定\n  ssl_session_cache   shared:SSL:10m;\n  # 配置会话超时时间\n  ssl_session_timeout 10m;\n  server {\n    listen 443;\n    server_name www.example.com;\n    ssl on;\n    # 设置长连接\n    keepalive_timeout 70;\n    # HSTS策略\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;\n    # 证书文件\n    ssl_certificate www.example.com.crt;\n    # 私钥文件\n    ssl_certificate_key www.example.com.key;  \n    # 优先采取服务器算法\n    ssl_prefer_server_ciphers on;\n    # 指定SSL协议\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    # 定义算法\n    ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\";\n    # 减少点击劫持\n    add_header X-Frame-Options DENY;\n    # 禁止服务器自动解析资源类型\n    add_header X-Content-Type-Options nosniff;\n    # 防XSS攻擊\n    add_header X-Xss-Protection 1;\n  }\n}\n```\n# Nginx作为反向代理服务器\n```\nserver {\n  listen 80;\n  server_name www.example.com;\n  root html;\n  index index.html;  \n  location /test {    \n    # 请求host\n    proxy_set_header Host $http_host;\n    # 请求ip\n    proxy_set_header X-Real-IP $remote_addr;\n    # 请求协议\n    proxy_set_header X-Scheme $scheme;\n    # 代理服务器\n    proxy_pass http://localhost:3000;\n  }\n}\n```\n当访问http://www.example.com/test时, nginx会将请求转发到http://localhost:3000上。\n# Nginx作为负载均衡\n+ 负载均衡的介绍  \n在服务器集群中，Nginx起到一个代理服务器的角色（即反向代理），为了避免单独一个服务器压力过大，将来自用户的请求转发给不同的服务器。  \n负载均衡用于从 “upstream” 模块定义的后端服务器列表中选取一台服务器接受用户的请求。\n\n+ 负载均衡的基本实例  \nUpstream模块\n一个最基本的upstream模块如下:\n```\n#动态服务器组, server是后端服务器，my_server是自定义的服务器组名称。\nupstream my_server {\n  server localhost:8001;\n  server localhost:8002;\n  server localhost:8003;\n}\n```\n反向代理  \n在upstream模块配置完成后，要让指定的访问反向代理到服务器组。\n```\nserver {\n  listen 80;\n  server_name www.example.com;\n  root html;\n  index index.html;\n  location / {    \n   # 反向代理到定义好的服务器组my_server\n   proxy_pass my_server;\n  }\n}\n```\n+ 完整配置\n```\nhttp {\n    upstream my_server {\n    server localhost:8001;\n    server localhost:8002;\n    server localhost:8003;\n  }\n    server {\n    listen      80;\n    server_name www.example.com;\n    root html;\n    index index.html;\n        location / {\n            # 反向代理到定义好的服务器组my_server\n            proxy_pass my_server;\n        }\n    }\n}\n```\n+ 负载均衡策略    \n\n(1) 轮询(默认方式)  \n表示每个请求按时间顺序逐一分配到不同的后端服务器。\n```\nupstream my_server {\n   server localhost:8001;\n   server localhost:8002;\n}\n```\n(2) Weight(权重方式)  \n表示在轮询策略的基础上指定轮询的服务器的权重，默认为1，权重越高分配到需要处理的请求越多。  \n```\nupstream my_server {\n  server localhost:8001 weight=1;\n  server localhost:8002 weight=2;\n}\n```\n(3) Ip_hash  \n表示指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。  \n```\nupstream my_server {\n  ip_hash;\n  server localhost:8001;\n  server localhost:8002;\n}\n```\n备注:  \n在nginx版本1.3.1之前，不能在ip_hash中使用权重（weight）。  \nip_hash不能与backup同时使用。  \n此策略适合有状态服务，比如session。  \n当有服务器需要剔除，必须手动down掉。    \n\n(4) Least_conn  \n表示把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。  \n```\nupstream my_server {\n  least_conn;\n  server localhost:8001;\n  server localhost:8002;\n}\n```\n(5) Down  \n表示当前的server暂时不参与负载均衡。  \n ```\nupstream my_server {\n  server localhost:8001 down;\n  server localhost:8002;\n  server localhost:8003;\n}\n```  \n(6) Backup  \n表示预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。  \n```\nupstream my_server {\n  server localhost:8001 backup;\n  server localhost:8002;\n  server localhost:8003;\n}\n```","time":1555645140558}